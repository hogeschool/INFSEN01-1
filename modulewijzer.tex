\documentclass{article}
\usepackage{longtable}
\usepackage{enumitem}

 \title{Course Description\\ Software Engineering 1}
 \date { }
 
 \begin{document}
    
    
    \maketitle
    
\section { Course description }

    \subsection{Introduction}\label{introduction}

This is the course descriptor for the Software Engineering course.

Software engineering 1 covers functors and monads, which are advanced
patterns used to structure code in a composable way to solve a variety
of problems in query-management, UI rendering, parallel processing, and
more. The focus of the course will be on the patterns, and not on a
pervasive philosophy of functional programming. These patterns are used
in the practice of modern mainstream programming languages, from C\# and
Java to the JavaScript world. For this reason, we will build examples in
TypeScript, a modern popular statically-typed variant of JavaScript with
both a rich type system and broad appeal for professionals.

Thanks to this course, students will understand advanced patterns and
the important principle of composition at a higher level of abstraction.

    \subsubsection{Learning goals}\label{learning-goals}

The course has the following learning goals: - (ICODE) students can
\emph{recognize and formally interpret} important properties of abstract
patterns such as associativity, preservation of identity, or
homomorphism; - (WCODE) students can \emph{write small snippets of code}
in order to complete the implementation of a known abstract pattern.

The course, and therefore also the learning goals, are limited to
\textbf{referentially transparent}, \textbf{type-safe} programs written
in TypeScript.

The corresponding competences connected to these learning goals are: -
realisation.

\subsubsection{Learning materials}\label{learning-materials}

The mandatory learning materials are: - reader of the lectures, which
will be made available one week after the lecture - materials on the
Github repository (github.com/hogeschool), which is already online

    \subsubsection{Exam}\label{exam}

The exam is divided in two parts: \#\#\#\# Theory - (MC) a series of
fifteen (15) \emph{multiple-choice} questions on the formal properties
of examples of code, ranging from associativity to functoriality and
more.

\paragraph{Practice}\label{practice}

\begin{itemize}[noitemsep]
\item
  (BA) a series of five (5) \emph{backward assignments}, that is
  exercises where students, given partial code implementing a monad or
  function, are requested to fill in the missing code that matches the
  given specification. All monads and functors seen in class may be
  asked here.
\end{itemize}

\paragraph{Scoring}\label{scoring}

The theory questions are worth one point each. The practice questions
are worth three points each. The maximum total score is therefore 30.

Both parts of the exam must score above 55\%: if there are more than 6
errors in the theory, or more than 2 errors in the practice, then the
points for the course will not be awarded and the insufficient part will
need to be retaken.

The final grade is computed as follows:

grade = score * 30 / 10

This is justified: even though there are more MC's than BA's, the BA's
require actively \emph{writing code}, which is significantly more
complex than providing a description of formal properties, seen that it
combines technical understanding and creativity.

\paragraph{Exam matrix}\label{exam-matrix}

The exam covers all learning goals.
\begin{table}[!h]
		\centering
	\begin{tabular}{|c|c|c|}
	\hline
	Exam part & ICODE & WCODE \\
	\hline
	MC & V & \\
	\hline
	BA & & V \\
	\hline
	\end{tabular}
\end{table}

    \subsection{Lecture plan}\label{lecture-plan}

The course is made up of eight lectures, usually planned as one lecture
per lesson week (for details, see lesson schedule on HINT).

The lesson units covered by the course are the following: - Types,
functions, and their composition - Functors, their implementation, and
properties - Monoids in set, monoids in programming - Monads as monoids
and (endo-) functors - Very simple monads: Identity - Sum monad(s):
Plus, Exception, Option - State monad - Composition of monads: Parser -
Composition of monads: Coroutine

Note that each lesson unit does not necessarily correspond to one lesson
week (for example, one lesson unit could span during two lesson weeks or
two lesson units could be handled during one lesson week).

    \subsection{Study points and contact
time}\label{study-points-and-contact-time}

The course awards students 4 ECTS, in correspondence with 112 hours of
study.

The course consists of eight frontal lectures for the theory, and eight
assisted practicums. The rest is self study.

\section{Lecture plan}\label{lecture-plan}

The course revolves around the building of abstractions which can be
safely composed. We will begin with a short discussion on our basic
toolbox, referentially transparent functions and types, and then start
defining abstract patterns such as functors and monoids.

We will then move onto a combination of the concepts of functor and
monoid, thereby obtaining monads. We will then show various monads which
have been proven to be powerful in actual programming practice.

\subsection{Basic toolbox}\label{basic-toolbox}

\begin{itemize}[noitemsep]
	\item
	Functions, types
	\item
	Composition of types and referential transparency
\end{itemize}

\subsection{Functors}\label{functors}

\begin{itemize}[noitemsep]

	\item
	Generic types as functions between types
	\item
	Generic types \emph{induce} \texttt{map}, which is a function between
	functions
	\item
	Examples:
	
	\begin{itemize}[noitemsep]

		\item
		Identity
		\item
		Pair (left, right, product)
		\item
		Sum (left, right, product)
		\item
		Option
		\item
		List
	\end{itemize}
	\item
	Properties of functors: preservation of identity and composition
	
	\begin{itemize}[noitemsep]

		\item
		Useful tip: performance optimization by merging maps
	\end{itemize}
	\item
	Functors can be composed into new functors
	
	\begin{itemize}[noitemsep]

		\item
		List(Option)
	\end{itemize}
\end{itemize}

\subsection{Monoids}\label{monoids}

\begin{itemize}[noitemsep]

	\item
	Fundamental structure which arises everywhere
	\item
	Joining, unit, associativity
	\item
	Examples:
	
	\begin{itemize}[noitemsep]

		\item
		string, plus, empty
		\item
		number, plus, 0
		\item
		number, times, 1
		\item
		list, concat, empty
		\item
		...
	\end{itemize}
	\item
	Monoids over functors:
	\item
	Reformulation of monoids in functional terms: unit becomes a function
	(eta/return)
\end{itemize}

\subsection{Monads introduction}\label{monads-introduction}

\begin{itemize}[noitemsep]

	\item
	Monads arise everywhere we can augment a functor with joining, unit,
	and associativity
	\item
	The bind operator
	\item
	Examples:
	
	\begin{itemize}[noitemsep]

		\item
		Identity (bind is simply function composition!)
		\item
		Pair (left and right)
	\end{itemize}
\end{itemize}

We now move on to more and more advanced monads which are quite useful
in practice.

\subsubsection{Sum(s)}\label{sums}

\begin{itemize}[noitemsep]

	\item
	Concept: safe representation of a happy-flow and an error flow\\
	\item
	Sum (left and right)
	\item
	Option
	\item
	Exception
	\item
	Examples:
	
	\begin{itemize}[noitemsep]

		\item
		Optional in Java
		\item
		Maybe in Haskell
		\item
		Optional in C++
	\end{itemize}
\end{itemize}

\subsubsection{State}\label{state}

\begin{itemize}[noitemsep]

	\item
	Concept: arbitrating state-management, own DSL
	\item
	Example:
	\item
	Mini-language
\end{itemize}

\subsubsection{Combining monads: parser}\label{combining-monads-parser}

\begin{itemize}[noitemsep]

	\item
	Concept: different monads can be composed together in order to form a
	larger monad
	
	\begin{itemize}[noitemsep]

		\item
		The larger monad is still a monad!
	\end{itemize}
	\item
	Let us show that parser is the combination of state and
	option/exception
	\item
	Example:
	
	\begin{itemize}[noitemsep]

		\item
		Parser for the mini-language from the State
		\item
		Mini-language with exceptions
	\end{itemize}
\end{itemize}

\subsubsection{Coroutines}\label{coroutines}

\begin{itemize}[noitemsep]

	\item
	Concept: modelling domain-specific concurrency in a concurrency-unsafe
	host-language
	\item
	Examples:
	
	\begin{itemize}[noitemsep]

		\item
		Promises
		\item
		TPL
		\item
		Mini-language with exceptions and breakpoints
	\end{itemize}
\end{itemize}
    
    
    
    \end{document}